# from qiling import Qiling
# from qiling.const import QL_VERBOSE
# import os

# # Tracks unique paths and syscalls to reduce clutter
# seen_syscalls = set()
# seen_paths = set()

# # Try to extract readable string from memory (for path-like args)
# def try_read_str(ql, ptr):
#     try:
#         return ql.mem.string(ptr)
#     except:
#         return f"(unreadable @ {ptr:#x})"

# # Hook for all syscalls
# def hook_all_syscalls(ql, syscall_id, args):
#     name = ql.os.resolve_syscall_name(syscall_id)
#     if name not in seen_syscalls:
#         seen_syscalls.add(name)

#     resolved_args = []
#     for arg in args:
#         if isinstance(arg, int):
#             val = try_read_str(ql, arg)
#             resolved_args.append(val if "/" in str(val) else f"{arg:#x}")
#         else:
#             resolved_args.append(str(arg))

#     print(f"[SYSCALL] {name}({', '.join(resolved_args)})")

# # Optional: instruction hook to confirm code is running
# def hook_code_exec(ql, addr, size):
#     print(f"[INSTR] Executing at {addr:#x}")

# def main():
#     elf_path = "e2d97525cffd1220bc5427f25dcc24137a0bcc6fd9a54e60fe94b15eba32eaad.elf"
#     rootfs_path = "/home/sg/qiling_rootfs/arm_linux"

#     if not os.path.exists(elf_path):
#         print(f"[ERROR] File not found: {elf_path}")
#         return

#     ql = Qiling(
#         [elf_path],
#         rootfs_path,
#         verbose=QL_VERBOSE.DEBUG
#     )

#     # Hook all syscalls (broad coverage)
#     ql.os.set_syscall("*", hook_all_syscalls)

#     # Optional: uncomment to see instruction execution
#     # ql.hook_code(hook_code_exec)

#     # Optional and safe mirroring (read-only)
#     ql.add_fs_mapper("/etc", "/etc")
#     ql.add_fs_mapper("/lib", "/lib")
#     ql.add_fs_mapper("/proc", "/proc")

#     print(f"[INFO] Starting emulation of {elf_path}")
#     ql.fs.set_fs_policy(True)  # allow sandbox to access more freely
#     try:
#         ql.run()
#     except Exception as e:
#         print(f"[CRASH] Emulation stopped due to error: {e}")

# if __name__ == "__main__":
#     main()


from qiling import Qiling
from qiling.const import QL_VERBOSE

seen_syscalls = set()

def try_read_str(ql, ptr):
    try:
        return ql.mem.string(ptr)
    except:
        return f"(unreadable @ {ptr:#x})"

def hook_all_syscalls(ql, syscall_id, args):
    name = ql.os.resolve_syscall_name(syscall_id)
    if name not in seen_syscalls:
        seen_syscalls.add(name)
    resolved = []
    for arg in args:
        if isinstance(arg, int):
            s = try_read_str(ql, arg)
            resolved.append(s if "/" in str(s) else f"{arg:#x}")
        else:
            resolved.append(str(arg))
    print(f"[SYSCALL] {name}({', '.join(resolved)})")

def main():
    elf = "e2d97525cffd1220bc5427f25dcc24137a0bcc6fd9a54e60fe94b15eba32eaad.elf"
    rootfs = "/home/sg/qiling_rootfs/arm_linux"

    ql = Qiling([elf], rootfs, verbose=QL_VERBOSE.DEBUG)

    ql.os.set_syscall("*", hook_all_syscalls)

    # ‚Üê Critical: mirror real host directories into Qiling's rootfs
    ql.add_fs_mapper("/lib", "/home/sg/qiling_rootfs/arm_linux/lib")
    ql.add_fs_mapper("/usr/lib", "/usr/lib")  # if needed
    ql.add_fs_mapper("/usr/arm-linux-gnueabihf/lib", "/usr/arm-linux-gnueabihf/lib")

    print(f"[INFO] Starting emulation of {elf}")
    try:
        ql.run()
    except Exception as e:
        print(f"[CRASH] Emulation stopped due to error: {e}")

if __name__ == "__main__":
    main()
